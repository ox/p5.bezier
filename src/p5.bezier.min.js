const p5bezierAccuracyListAll=[.2,.1,.05,.04,.02,.01,.008,.002,.001,5e-4,1e-4];let _canvas,_ctx,_dimension,_strict;export function initBezier(a,b=!1){_canvas=a,_ctx=_canvas.drawingContext,_dimension=a.isP3D?3:2,_strict=b}export function newBezier(a,b="OPEN",c=7){if(_strict&&!Array.isArray(a))throw"newBezier() function expects an array, got %s.",typeof a;const e=p5bezierAccuracyListAll[c];if(0!==_dimension){if(_strict)for(let b of a)if(!Array.isArray(a)||b.length!==_dimension)throw"One or more points in the array are not input correctly.";"CLOSE"===b&&a.push(a[0]);let c=a.length,f=c-1;if(_ctx.beginPath(),_ctx.moveTo(...a[0]),2===_dimension){let b,c,d,g;for(d=0;1>=d;d+=e){for(b=0,c=0,g=0;g<=f;g++)b+=_helper_factorial(f)/(_helper_factorial(g)*_helper_factorial(f-g))*Math.pow(1-d,f-g)*Math.pow(d,g)*a[g][0],c+=_helper_factorial(f)/(_helper_factorial(g)*_helper_factorial(f-g))*Math.pow(1-d,f-g)*Math.pow(d,g)*a[g][1];_ctx.lineTo(b,c)}_ctx.lineTo(...a.slice(-1)[0])}else if(3===_dimension){let b,c,g,d=[0,0,0];for(b=0;1>=b;b+=e){for(d=[0,0,0],c=0;c<=f;c++)for(g=0;3>g;g++)d[g]+=_helper_factorial(f)/(_helper_factorial(c)*_helper_factorial(f-c))*Math.pow(1-b,f-c)*Math.pow(b,c)*a[c][g];_ctx.lineTo(...d)}_ctx.lineTo(...a.slice(-1)[0])}if("CLOSE"===b)_ctx.closePath();else if(_strict&&"OPEN"!==b)throw"Close Type Error. A bezier curve can only be either OPEN or CLOSE.";return void _helper_style()}}export function newBezierObj(a,b="OPEN",c=7){const d=p5bezierAccuracyListAll[c];if(_strict&&!Array.isArray(a))throw"newBezier() function expects an array, got %s.",typeof a;if(_strict)for(let b of a)if(!Array.isArray(a)||b.length!==_dimension)throw"One or more points in the array are not input correctly.";let e=new BezierCurve(a,b,d,_dimension);return e}function _helper_factorial(b){return 1<b?b*_helper_factorial(b-1):1}function _helper_dist(){if(4===arguments.length)return Math.hypot(arguments[0]-arguments[2],arguments[1]-arguments[3]);return 6===arguments.length?Math.hypot(arguments[0]-arguments[3],arguments[1]-arguments[4],arguments[2]-arguments[5]):0}function _helper_style(){_canvas._doFill&&_ctx.fill(),_canvas._doStroke&&_ctx.stroke()}class BezierCurve{constructor(a,b,c,d,e=null){if(_strict&&2!==d&&3!==d)throw"Dimension Error. The bezier curve is %d-dimensional and doesn't belong to our world.",d;if(this.controlPoints=a,"CLOSE"===b)this.controlPoints.push(a[0]),this.closeType="CLOSE";else if("OPEN"===b)this.closeType="OPEN";else throw"Close Type Error. A bezier curve can only be either OPEN or CLOSE.";this.dimension=d,this.increment=c,this.vertexList=[],this.vertexListLen=0,this.p=this.controlPoints.length,this.n=this.p-1,null===e?this._buildVertexList():(this.vertexList=e,this.vertexListLen=this.vertexList.length)}_buildVertexList(){if(this.vertexList=[],2===this.dimension){let a,b,c,d;for(c=0;1>=c;c+=this.increment){for(a=0,b=0,d=0;d<=this.n;d++)a+=_helper_factorial(this.n)/(_helper_factorial(d)*_helper_factorial(this.n-d))*Math.pow(1-c,this.n-d)*Math.pow(c,d)*this.controlPoints[d][0],b+=_helper_factorial(this.n)/(_helper_factorial(d)*_helper_factorial(this.n-d))*Math.pow(1-c,this.n-d)*Math.pow(c,d)*this.controlPoints[d][1];this.vertexList.push([a,b])}}else if(3===this.dimension){let a,b,c,d=[0,0,0];for(a=0;1>=a;a+=this.increment){for(d[0]=0,d[1]=0,d[2]=0,b=0;b<=this.n;b++)for(c=0;3>c;c++)d[c]+=_helper_factorial(this.n)/(_helper_factorial(b)*_helper_factorial(this.n-b))*Math.pow(1-a,this.n-b)*Math.pow(a,b)*this.controlPoints[b][c];this.vertexList.push(d)}}return this._addVertex(this.controlPoints.slice(-1)[0]),this.dimension=this.vertexList[0].length,this.vertexListLen=this.vertexList.length,this.vertexList}_addVertex(a){if(2===this.dimension||3===this.dimension)_ctx.lineTo(...a);else throw"Vertices can only be in 2D or 3D space."}_distVertex(a,b){if(2===this.dimension)return _helper_dist(a[0],a[1],b[0],b[1]);return 3===this.dimension?_helper_dist(a[0],a[1],a[2],b[0],b[1],b[2]):void 0}draw(a){if(!a){_ctx.beginPath();for(let a of this.vertexList)this._addVertex(a);"CLOSE"===this.closeType&&_ctx.closePath(),_helper_style()}else if(Array.isArray(a)&&2===a.length&&.008>=this.increment){let b=Math.abs(a[0]),c=b+Math.abs(a[1]),d=0,e=0,f=this.vertexList[0],g=!0;_ctx.save(),_ctx.fillStyle="rgba(0, 0, 0, 0)",_ctx.beginPath(),_ctx.moveTo(...this.vertexList[0]);for(let a=1;a<this.vertexListLen;a++)d+=this._distVertex(f,this.vertexList[a]),e=d%c,e<=b&&g?this._addVertex(this.vertexList[a]):e>b&&e<=c&&g?g=!1:e<=b&&!g&&(_ctx.moveTo(...this.vertexList[a]),g=!0),f=this.vertexList[a];_helper_style(),_ctx.restore()}else if(.008<this.increment)throw"Fidelity is too low for a dash line. It should be at least 6.";else throw"Your dash array input is not valid. Make sure it's an array of two numbers."}update(a){if(a.length!==this.controlPoints)throw"The number of points changed. (Keep the point array length the same.)";else if(this.controlPoints===a);else this.controlPoints=a,this._buildVertexList()}move(a,b,c=null,d=!0,e=0){if(null===c&&3===this.dimension)throw"To move a 3D curve, please specify (x, y, z).";else{let f=[a,b];null!==c&&f.push(c);let g=[];for(let a=0;a<this.vertexListLen;a++)g.push(this.vertexList[a].slice());let h=new BezierCurve(this.controlPoints,this.closeType,this.increment,this.dimension,g);for(let a=0;a<h.vertexListLen;a++)for(let b=0;b<h.dimension;b++)h.vertexList[a][b]+=f[b];return d&&h.draw(e),h}}shortest(a,b,c=0){let d,e=-1,f=0;for(let g of this.vertexList)-1===e?(e=this._distVertex(g,[a,b,c]),d=g):(f=this._distVertex(g,[a,b,c]),e>f&&(e=f,d=g));return d}}